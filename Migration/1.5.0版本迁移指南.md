# 1.5版本迁移指南

# 删除了`JXCategoryListCollectionContainerView`类

请使用`JXCategoryListContainerView`类，初始化的时候给type赋值`JXCategoryListContainerType_CollectionView`，就相当于使用了以前的`JXCategoryListCollectionContainerView`了。

# 删除`addChildViewController`方法和列表是VC可以删除自定义的`naviController`属性

因为`JXCategoryListContainerView`视图内部自己创建了一个`JXCategoryListContainerViewController`视图控制器，用于管理所有的列表生命周期。所以，外部无需再对列表VC调用`addChildViewController`方法。
如果你的列表是VC，可以删除自定义的`naviController`，列表VC可以访问vc.navigationController即可。如果你的列表是视图还是需要传递导航栏控制器的。
```Objective-C
- (id<JXCategoryListContentViewDelegate>)listContainerView:(JXCategoryListContainerView *)listContainerView initListForIndex:(NSInteger)index {
    LoadDataListContainerListViewController *listVC = [[LoadDataListContainerListViewController alloc] init];
    //⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️如果你的列表是VC，删除自定义的`naviController`。如果你的列表是视图还是需要传递导航栏控制器的⚠️⚠️⚠️⚠️⚠️⚠️⚠️
    //listVC.naviController = self.navigationController;
    //⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️删除`addChildViewController`⚠️⚠️⚠️⚠️⚠️⚠️⚠️
    //[self addChildViewController:listVC];
    listVC.title = self.titles[index];
    return listVC;
}
```

# 外部整个页面的VC无需调用`- (BOOL)shouldAutomaticallyForwardAppearanceMethods`方法

因为`JXCategoryListContainerView`内部的`JXCategoryListContainerViewController`已经处理了视图生命周期方法的传递，所以外部VC无需关心。

# `JXCategoryBaseView`新增`listContainer`属性

请不要再使用`contentScrollView`属性。使用示例如下：
```
//初始化JXCategoryListContainerView
self.listContainerView = [[JXCategoryListContainerView alloc] initWithType:JXCategoryListContainerType_ScrollView delegate:self];
[self.view addSubview:self.listContainerView];

//然后初始化JXCategoryTitleView，并赋值给listContainer属性。
self.categoryView = [[JXCategoryTitleView alloc] init];
self.categoryView.listContainer = self.listContainerView;
[self.view addSubview:self.categoryView];
```

比使用`contentScrollView`的优势是：
- 无需自己调用`didClickSelectedItemAtIndex:(NSInteger)index`和`scrollingFromLeftIndex:(NSInteger)leftIndex toRightIndex:(NSInteger)rightIndex ratio:(CGFloat)ratio selectedIndex:(NSInteger)selectedIndex`两个API;
- 配置`defaultSelectedIndex`属性时，需要要设置给`JXCategoryView`即可，内部会同步给`JXCategoryListContainerView`；
- 调动`reloadData`方法时，`JXCategoryView`会同步调用`JXCategoryListContainerView`的`reloadData`方法；

总的来说，使用`listContainer`属性，封装度更高，你无需关心许多API的调用了。



